/* 1. Таблица #oper хранит информацию о количестве произведенных операций на каждую календарную дату.  
Вывести на каждую дату количества операций, совершенное с начала месяца по указанную дату включительно накопительным итогом. 
*/

BEGIN TRANSACTION;

CREATE TABLE oper ([date] date, cnt int);

insert into oper
values ('2019-06-02',     1985), 
    ('2019-06-03',     1577), 
    ('2019-06-04',     1597), 
    ('2019-06-05',     1468), 
    ('2019-07-06',     82), 
    ('2019-07-08',     1689), 
    ('2019-07-09',     1556), 
    ('2019-07-10',     1480), 
    ('2019-07-11',     1405), 
    ('2019-07-12',     1502);

SELECT date, SUM(cnt) OVER (PARTITION BY STRFTIME("%m-%Y", date) ORDER BY date) AS N_OPS
FROM oper;

/* Output:
2019-06-02|1985
2019-06-03|3562
2019-06-04|5159
2019-06-05|6627
2019-07-06|82
2019-07-08|1771
2019-07-09|3327
2019-07-10|4807
2019-07-11|6212
2019-07-12|7714
*/

/* 2. Даны месячные срезы сегментов клиентов, нужно получить по каждому клиенту периоды действия каждого сегмента. 
NB! Если известна только одна дата действия сегмента, то считается что период для сегмента еще не закончился и нам известна только дата начала периода. Соответственно дата окончания периода должна быть представлена в виде null
*/

BEGIN TRANSACTION;

CREATE TABLE segment ([date] date, ClientID varchar(6), SegmentID int);

insert into segment
values ('2018-01-31' ,'A11111', 2), 
    ('2018-02-28' ,'A11111', 2), 
    ('2018-03-31' ,'A11111', 1), 
    ('2018-04-30' ,'A11111', 1), 
    ('2017-11-30' ,'B22222', 1), 
    ('2017-10-31' ,'B22222', 1), 
    ('2017-09-30' ,'B22222', 3), 
    ('2017-09-30' ,'C33333', 1), 
    ('2017-10-31' ,'C33333', 1); 

SELECT ClientID, SegmentID, min(date), IIF(min(date)=max(date), NULL, max(date)) FROM segment
GROUP BY ClientID, SegmentID;

/* Output:
A11111|1|2018-03-31|2018-04-30
A11111|2|2018-01-31|2018-02-28
B22222|1|2017-10-31|2017-11-30
B22222|3|2017-09-30|
C33333|1|2017-09-30|2017-10-31
*/

/* 3. Есть список карт лояльности клиентов. Необходимо написать запрос, который вернет карты клиентов которые совершали покупки 2 месяца подряд и более.
*/

BEGIN TRANSACTION;

CREATE TABLE purchase (bonuscard int, date_purchase date);

insert into purchase 
values (2133, '2020-01-12'),
    (4791, '2020-03-02'),
    (1589, '2020-07-10'),
    (4455, '2020-12-22'),
    (6037, '2020-01-31'),
    (2133, '2020-03-18'),
    (1589, '2020-03-12'),
    (4791, '2020-05-02'),
    (4455, '2021-01-13'),
    (2133, '2020-01-03'),
    (6037, '2020-02-19'),
    (2133, '2020-01-10'),
    (1589, '2020-04-15'),
    (6037, '2020-08-07');

SELECT DISTINCT bonuscard
FROM purchase AS p1
WHERE EXISTS (
    SELECT 1
    FROM purchase AS p2
    WHERE p1.bonuscard = p2.bonuscard
        AND strftime('%Y-%m', p2.date_purchase, 'start of month', '+1 month') = strftime('%Y-%m', p1.date_purchase, 'start of month')
)
ORDER BY bonuscard;

/* Output:
1589
4455
6037
*/

/* 4. Отобрать клиентов по г. Москва с суммарными остатками по клиенту от 20 000 на последнюю дату. */

create table Clients (client_id varchar(1), FIO varchar (255) , Region varchar(50), account_num int) 
insert into Clients values  
('A','Иванов','Москва',111), 
('A','Иванов','Москва',222), 
('B','Петров','Иваново',333), 
('C','Сидоров','Москва',444) 
   
create table Accounts ([Date] date, Summa_USD money, Account_num int) 
insert into Accounts values 
('2012-01-01',15000,111), 
('2012-02-01',10000,111), 
('2012-02-01',5000,222), 
('2012-03-01',30000,333), 
('2012-04-01',20000,444);

SELECT client_id, FIO, Region, Summa_USD AS Total_USD
FROM Clients AS C
JOIN (
    SELECT Account_num, Summa_USD
    FROM Accounts
    WHERE [Date] = (
        SELECT MAX([Date])
        FROM Accounts
        WHERE Account_num = Accounts.Account_num
    )
) AS A ON C.account_num = A.Account_num
WHERE C.Region = 'Москва' AND A.Summa_USD >= 20000

/* Output
client_id	FIO	region	TotalAmount_USD
C	Сидоров	Москва	20000
*/

/* Замечания:
Хранение местонахождения клиентов в одной таблице может привести к ошибкам. В случае, если в одной из строк при смене информации о клиенте адрес не будет уточнен, запросы могут давать неверную информацию. Лучше хранить информацию о клиенте в отдельной таблице.*/

/* 5. Таблица #oper хранит информацию о количестве произведенных операций на каждую календарную дату.  
Вывести на каждую дату количества операций, совершенное с начала месяца по указанную дату включительно накопительным итогом. */

create table oper (date date, cnt int) 
insert into oper values 
('2019-06-02',     1985), 
('2019-06-03',     1577), 
('2019-06-04',     1597), 
('2019-06-05',     1468), 
('2019-07-06',     82), 
('2019-07-08',     1689), 
('2019-07-09',     1556), 
('2019-07-10',     1480), 
('2019-07-11',     1405), 
('2019-07-12',     1502);

SELECT date, SUM(cnt) OVER (PARTITION BY YEAR(date), MONTH(date) ORDER BY date) AS total_cnt
FROM oper;

/* Output
date	total_cnt
2019-06-02	1985
2019-06-03	3562
2019-06-04	5159
2019-06-05	6627
2019-07-06	82
2019-07-08	1771
2019-07-09	3327
2019-07-10	4807
2019-07-11	6212
2019-07-12	7714
*/

/* 6. Даны месячные срезы сегментов клиентов, нужно получить по каждому клиенту периоды действия каждого сегмента. */

create table segment ([date] date, ClientID varchar(6),SegmentID int) 
insert into segment values  
('2018-01-31' ,'A11111', 2), 
('2018-02-28' ,'A11111', 2), 
('2018-03-31' ,'A11111', 1), 
('2018-04-30' ,'A11111', 1), 
('2017-11-30' ,'B22222', 1), 
('2017-10-31' ,'B22222', 1), 
('2017-09-30' ,'B22222', 3), 
('2017-09-30' ,'C33333', 1), 
('2017-10-31' ,'C33333', 1) 

SELECT ClientID, SegmentID, DATEADD(MONTH, DATEDIFF(MONTH, 0, MIN([date])), 0) AS StartDate, MAX([date]) AS EndDate
FROM segment
GROUP BY ClientID, SegmentID
ORDER BY ClientID, SegmentID;

/* Output
ClientID	SegmentID	StartDate	EndDate
A11111	1	2018-03-01	2018-04-30
A11111	2	2018-01-01	2018-02-28
B22222	1	2017-10-01	2017-11-30
B22222	3	2017-09-01	2017-09-30
C33333	1	2017-09-01	2017-10-31
*/

/* Замечания:
Предполагаем, что в таблице указаны месяцы, когда клиент находился в сегменте, тогда, если строка с сегментом только одна, значит клиент был в сегменте только один месяц*/